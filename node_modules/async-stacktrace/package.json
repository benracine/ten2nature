{
  "name": "async-stacktrace",
  "description": "Improves node.js stacktraces and makes it easier to handle errors",
  "homepage": "https://github.com/Pita/async-stacktrace",
  "author": {
    "name": "Peter 'Pita' Martischka",
    "email": "petermartischka@googlemail.com"
  },
  "devDependencies": {
    "vows": "0.6.0"
  },
  "main": "./ERR",
  "version": "0.0.3-new-features.3",
  "readme": "## Why classic stacktraces are not very helpful when dealing with async functions\n\nLook at this example. `one` calls `two`, `two` calls `three`, and `three` calls `four`. All functions call the given callback asynchronous. `four` calls the callback with an error. `three` and `two` passes the error to their callback function and stop executing with `return`. `one` finally throws it \n\n```js\nfunction one()\n{\n   two(function(err){\n     if(err){\n       throw err;\n     }\n   \n     console.log(\"two finished\");\n   });\n}\n\nfunction two(callback)\n{\n  setTimeout(function () { \n    three(function(err)\n    {\n      if(err) {\n        callback(err);\n        return;\n      }\n      \n      console.log(\"three finished\");\n      callback();\n    });\n  }, 0);\n}\n\nfunction three(callback)\n{\n  setTimeout(function () { \n    four(function(err)\n    {\n      if(err) {\n        callback(err);\n        return;\n      } \n      \n      console.log(\"four finished\");\n      callback();\n    });\n  }, 0);\n}\n\nfunction four(callback)\n{\n  setTimeout(function(){\n    callback(new Error());\n  }, 0);\n}\n\none();\n```\n\n### When you execute it, you will get this:\n\n```\n$ node example_without.js \n\n/home/pita/Code/async-stacktrace/example_without.js:5\n       throw err;\n       ^\nError\n    at Timer.callback (/home/pita/Code/async-stacktrace/example_without.js:47:14)\n```\n\n### The problems here are:\n\n* You can see that the error happend in `four`, but you can't see from where `four` was called. The context gets lost\n* You write the same 4 lines over and over again, just to handle errors\n\n## The solution\n\n### Lets replace this code in `two` and `three` \n\n```js\nif(err) {\n  callback(err);\n  return;\n}\n```\n\n### with\n\n```js\nif(ERR(err, callback)) return;\n```\n\n### and replace this code in `one`\n\n```js\nif(err){\n  throw err;\n}\n```\n\n### with\n\n```js\nERR(err);\n```\n\n### This is how it looks like now: \n\n```js\nvar ERR = require(\"async-stacktrace\");\n\nfunction one()\n{\n   two(function(err){\n     ERR(err);\n   \n     console.log(\"two finished\");\n   });\n}\n\nfunction two(callback)\n{\n  setTimeout(function () { \n    three(function(err)\n    {\n      if(ERR(err, callback)) return;\n      \n      console.log(\"three finished\");\n      callback();\n    });\n  }, 0);\n}\n\nfunction three(callback)\n{\n  setTimeout(function () { \n    four(function(err)\n    {\n      if(ERR(err, callback)) return;\n      \n      console.log(\"four finished\");\n      callback();\n    });\n  }, 0);\n}\n\nfunction four(callback)\n{\n  setTimeout(function(){\n    callback(new Error());\n  }, 0);\n}\n\none();\n```\n\n### When you execute it, you will get this:\n\n```\n$ node example.js \n\n/home/pita/Code/async-stacktrace/ERR.js:57\n      throw err;\n      ^\nAsync Stacktrace:\n    at /home/pita/Code/async-stacktrace/example.js:6:6\n    at /home/pita/Code/async-stacktrace/example.js:17:10\n    at /home/pita/Code/async-stacktrace/example.js:30:10\n\nError\n    at Timer.callback (/home/pita/Code/async-stacktrace/example.js:41:14)\n```\n\n### What is new?\n\nThe \"Async Stacktrace\" shows you where this error was caught and passed to the next callback. This allows you to see from where `four` was called. You also have less code to write\n\n## npm\n```\nnpm install async-stacktrace\n```\n\n## Usage\n\nThis is how you require the ERR function\n\n```js\nvar ERR = require(\"async-stacktrace\");\n```\n\nThe parameters of `ERR()` are: \n\n1. `err` The error object (can be a string that describes the error too)\n2. `callback` (optional) If the callback is set and an error is passed, it will call the callback with the modified stacktrace. Otherwise it will do nothing (the caller can pass the returned `err` object to the callback if desired).\n\nThe return value is the `err` object passed as the first parameter (if it was passed as a string, it will be returned as a first-class `Error()` object).\n\n### Alternate Usage\n\nIf all the work that is done in a function is done synchronously before an async call, it can be preferable to simply pass the callback directly to the async call, like this:\n\n```js\nfunction getUsers(db, callback) {\n  var sql = 'SELECT * FROM users';\n  db.query(sql, callback);\n}\n```\n\n`ERR()` can be used in this scenario as well. If it is passed a callback as its first argument, it will wrap the callback, caching the current stacktrace line. When the callback is executed, it will check for an error object and -- if one is exists -- it will add the cached stacktrace line to it:\n\n```js\nfunction getUsers(db, callback) {\n  var sql = 'SELECT * FROM users';\n  db.query(sql, ERR(callback));\n}\n```",
  "readmeFilename": "README.md",
  "_id": "async-stacktrace@0.0.3-new-features.3",
  "dist": {
    "shasum": "575f0a6496f09d80575254635d3d818577f76fd8"
  },
  "_resolved": "git+https://github.com/CSNW/async-stacktrace.git#959216f34df84a41ccd24f176ba374c6e3caf276",
  "_from": "async-stacktrace@git+https://github.com/CSNW/async-stacktrace.git#0.0.3-new-features.3"
}

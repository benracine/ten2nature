// node_modules/marked/lib/marked.js
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){3,} *\n*/,
  blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\w+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!' + block.gfm.fences.source.replace('\\1', '\\2') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i+1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item[item.length-1] === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start',
          value: this.options.preserveNumbering
            ? /^ *(\d+\.)?/.exec(cap[i])[1]
            : null
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre',
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1][cap[1].length-1] === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([^\s]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1][6] === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // url (gfm)
    if (cap = this.rules.url.exec(src)) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += '<a href="'
        + href
        + '">'
        + text
        + '</a>';
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0][0];
        src = cap[0].substring(1) + src;
        continue;
      }
      out += this.outputLink(cap, link);
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<strong>'
        + this.output(cap[2] || cap[1])
        + '</strong>';
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<em>'
        + this.output(cap[2] || cap[1])
        + '</em>';
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<code>'
        + escape(cap[2], true)
        + '</code>';
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<br>';
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += '<del>'
        + this.output(cap[1])
        + '</del>';
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(cap[0]);
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  if (cap[0][0] !== '!') {
    return '<a href="'
      + escape(link.href)
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>'
      + this.output(cap[1])
      + '</a>';
  } else {
    return '<img src="'
      + escape(link.href)
      + '" alt="'
      + escape(cap[1])
      + '"'
      + (link.title
      ? ' title="'
      + escape(link.title)
      + '"'
      : '')
      + '>';
  }
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length-1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return '<hr>\n';
    }
    case 'heading': {
      return '<h'
        + this.token.depth
        + '>'
        + this.inline.output(this.token.text)
        + '</h'
        + this.token.depth
        + '>\n';
    }
    case 'code': {
      if (this.options.highlight) {
        var code = this.options.highlight(this.token.text, this.token.lang);
        if (code != null && code !== this.token.text) {
          this.token.escaped = true;
          this.token.text = code;
        }
      }

      if (!this.token.escaped) {
        this.token.text = escape(this.token.text, true);
      }

      return '<pre><code'
        + (this.token.lang
        ? ' class="'
        + this.options.langPrefix
        + this.token.lang
        + '"'
        : '')
        + '>'
        + this.token.text
        + '</code></pre>\n';
    }
    case 'table': {
      var body = ''
        , heading
        , i
        , row
        , cell
        , j;

      // header
      body += '<thead>\n<tr>\n';
      for (i = 0; i < this.token.header.length; i++) {
        heading = this.inline.output(this.token.header[i]);
        body += this.token.align[i]
          ? '<th align="' + this.token.align[i] + '">' + heading + '</th>\n'
          : '<th>' + heading + '</th>\n';
      }
      body += '</tr>\n</thead>\n';

      // body
      body += '<tbody>\n'
      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];
        body += '<tr>\n';
        for (j = 0; j < row.length; j++) {
          cell = this.inline.output(row[j]);
          body += this.token.align[j]
            ? '<td align="' + this.token.align[j] + '">' + cell + '</td>\n'
            : '<td>' + cell + '</td>\n';
        }
        body += '</tr>\n';
      }
      body += '</tbody>\n';

      return '<table>\n'
        + body
        + '</table>\n';
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return '<blockquote>\n'
        + body
        + '</blockquote>\n';
    }
    case 'list_start': {
      var type = this.token.ordered ? 'ol' : 'ul'
        , body = '';

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return '<'
        + type
        + '>\n'
        + body
        + '</'
        + type
        + '>\n';
    }
    case 'list_item_start': {
      var body = '', val_attr = '';
      if (this.options.preserveNumbering && this.token.value)
        val_attr = ' value="' + this.token.value.replace('.', '') + '"';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return '<li' + val_attr + '>'
        + body
        + '</li>\n';
    }
    case 'loose_item_start': {
      var body = '', val_attr = '';
      if (this.options.preserveNumbering && this.token.value)
        val_attr = ' value="' + this.token.value.replace('.', '') + '"';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return '<li' + val_attr + '>'
        + body
        + '</li>\n';
    }
    case 'html': {
      return !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
    }
    case 'paragraph': {
      return '<p>'
        + this.inline.output(this.token.text)
        + '</p>\n';
    }
    case 'text': {
      return '<p>'
        + this.parseText()
        + '</p>\n';
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

/**
 * Marked
 */

function marked(src, opt) {
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  preserveNumbering: false,
  langPrefix: 'lang-'
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

// node_modules/diff/diff.js
/* See LICENSE file for terms of use */

/*
 * Text diff implementation.
 * 
 * This library supports the following APIS:
 * JsDiff.diffChars: Character by character diff
 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
 * JsDiff.diffLines: Line based diff
 * 
 * JsDiff.diffCss: Diff targeted at CSS content
 * 
 * These methods are based on the implementation proposed in
 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
 */
var JsDiff = (function() {
  function clonePath(path) {
    return { newPos: path.newPos, components: path.components.slice(0) };
  }
  function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, "&amp;");
    n = n.replace(/</g, "&lt;");
    n = n.replace(/>/g, "&gt;");
    n = n.replace(/"/g, "&quot;");

    return n;
  }

  var fbDiff = function(ignoreWhitespace) {
    this.ignoreWhitespace = ignoreWhitespace;
  };
  fbDiff.prototype = {
      diff: function(oldString, newString) {
        // Handle the identity case (this is due to unrolling editLength == 0
        if (newString == oldString) {
          return [{ value: newString }];
        }
        if (!newString) {
          return [{ value: oldString, removed: true }];
        }
        if (!oldString) {
          return [{ value: newString, added: true }];
        }

        newString = this.tokenize(newString);
        oldString = this.tokenize(oldString);

        var newLen = newString.length, oldLen = oldString.length;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{ newPos: -1, components: [] }];

        // Seed editLength = 0
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {
          return bestPath[0].components;
        }

        for (var editLength = 1; editLength <= maxEditLength; editLength++) {
          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {
            var basePath;
            var addPath = bestPath[diagonalPath-1],
                removePath = bestPath[diagonalPath+1];
            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              // No one else is going to attempt to use this value, clear it
              bestPath[diagonalPath-1] = undefined;
            }

            var canAdd = addPath && addPath.newPos+1 < newLen;
            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = undefined;
              continue;
            }

            // Select the diagonal that we want to branch from. We select the prior
            // path whose position in the new string is the farthest from the origin
            // and does not pass the bounds of the diff graph
            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
              basePath = clonePath(removePath);
              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);
            } else {
              basePath = clonePath(addPath);
              basePath.newPos++;
              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);
            }

            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);

            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {
              return basePath.components;
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
        }
      },

      pushComponent: function(components, value, added, removed) {
        var last = components[components.length-1];
        if (last && last.added === added && last.removed === removed) {
          // We need to clone here as the component clone operation is just
          // as shallow array clone
          components[components.length-1] =
            {value: this.join(last.value, value), added: added, removed: removed };
        } else {
          components.push({value: value, added: added, removed: removed });
        }
      },
      extractCommon: function(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath;
        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {
          newPos++;
          oldPos++;

          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);
        }
        basePath.newPos = newPos;
        return oldPos;
      },

      equals: function(left, right) {
        var reWhitespace = /\S/;
        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {
          return true;
        } else {
          return left == right;
        }
      },
      join: function(left, right) {
        return left + right;
      },
      tokenize: function(value) {
        return value;
      }
  };

  var CharDiff = new fbDiff();

  var WordDiff = new fbDiff(true);
  WordDiff.tokenize = function(value) {
    return removeEmpty(value.split(/(\s+|\b)/));
  };

  var CssDiff = new fbDiff(true);
  CssDiff.tokenize = function(value) {
    return removeEmpty(value.split(/([{}:;,]|\s+)/));
  };

  var LineDiff = new fbDiff();
  LineDiff.tokenize = function(value) {
    return value.split(/^/m);
  };

  return {
    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },
    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },
    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },

    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },

    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {
      var ret = [];

      ret.push("Index: " + fileName);
      ret.push("===================================================================");
      ret.push("--- " + fileName + (typeof oldHeader === "undefined" ? "" : "\t" + oldHeader));
      ret.push("+++ " + fileName + (typeof newHeader === "undefined" ? "" : "\t" + newHeader));

      var diff = LineDiff.diff(oldStr, newStr);
      if (!diff[diff.length-1].value) {
        diff.pop();   // Remove trailing newline add
      }
      diff.push({value: "", lines: []});   // Append an empty value to make cleanup easier

      function contextLines(lines) {
        return lines.map(function(entry) { return ' ' + entry; });
      }
      function eofNL(curRange, i, current) {
        var last = diff[diff.length-2],
            isLast = i === diff.length-2,
            isLastOfType = i === diff.length-3 && (current.added !== last.added || current.removed !== last.removed);

        // Figure out if this is the last line for the given file and missing NL
        if (!/\n$/.test(current.value) && (isLast || isLastOfType)) {
          curRange.push('\\ No newline at end of file');
        }
      }

      var oldRangeStart = 0, newRangeStart = 0, curRange = [],
          oldLine = 1, newLine = 1;
      for (var i = 0; i < diff.length; i++) {
        var current = diff[i],
            lines = current.lines || current.value.replace(/\n$/, "").split("\n");
        current.lines = lines;

        if (current.added || current.removed) {
          if (!oldRangeStart) {
            var prev = diff[i-1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;

            if (prev) {
              curRange = contextLines(prev.lines.slice(-4));
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?"+":"-") + entry; }));
          eofNL(curRange, i, current);

          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            // Close out any changes that have been output (or join overlapping)
            if (lines.length <= 8 && i < diff.length-2) {
              // Overlapping
              curRange.push.apply(curRange, contextLines(lines));
            } else {
              // end the range and output
              var contextSize = Math.min(lines.length, 4);
              ret.push(
                  "@@ -" + oldRangeStart + "," + (oldLine-oldRangeStart+contextSize)
                  + " +" + newRangeStart + "," + (newLine-newRangeStart+contextSize)
                  + " @@");
              ret.push.apply(ret, curRange);
              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
              if (lines.length <= 4) {
                eofNL(ret, i, current);
              }

              oldRangeStart = 0;  newRangeStart = 0; curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      }

      return ret.join('\n') + '\n';
    },

    applyPatch: function(oldStr, uniDiff) {
      var diffstr = uniDiff.split("\n");
      var diff = [];
      var remEOFNL = false,
          addEOFNL = false;

      for (var i = (diffstr[0][0]=="I"?4:0); i < diffstr.length; i++) {
        if(diffstr[i][0] == "@") {
          var meh = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
          diff.unshift({
            start:meh[3],
            oldlength:meh[2],
            oldlines:[],
            newlength:meh[4],
            newlines:[]
          });
        } else if(diffstr[i][0] == '+') {
          diff[0].newlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] == '-') {
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] == ' ') {
          diff[0].newlines.push(diffstr[i].substr(1));
          diff[0].oldlines.push(diffstr[i].substr(1));
        } else if(diffstr[i][0] == '\\') {
          if (diffstr[i-1][0] == '+') {
            remEOFNL = true;
          } else if(diffstr[i-1][0] == '-') {
            addEOFNL = true;
          }
        }
      }

      var str = oldStr.split("\n");
      for (var i = diff.length - 1; i >= 0; i--) {
        var d = diff[i];
        for (var j = 0; j < d.oldlength; j++) {
          if(str[d.start-1+j] != d.oldlines[j]) {
            return false;
          }
        }
        Array.prototype.splice.apply(str,[d.start-1,+d.oldlength].concat(d.newlines));
      }

      if (remEOFNL) {
        while (!str[str.length-1]) {
          str.pop();
        }
      } else if (addEOFNL) {
        str.push('');
      }
      return str.join('\n');
    },

    convertChangesToXML: function(changes){
      var ret = [];
      for ( var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push("<ins>");
        } else if (change.removed) {
          ret.push("<del>");
        }

        ret.push(escapeHTML(change.value));

        if (change.added) {
          ret.push("</ins>");
        } else if (change.removed) {
          ret.push("</del>");
        }
      }
      return ret.join("");
    },

    // See: http://code.google.com/p/google-diff-match-patch/wiki/API
    convertChangesToDMP: function(changes){
      var ret = [], change;
      for ( var i = 0; i < changes.length; i++) {
        change = changes[i];
        ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);
      }
      return ret;
    }
  };
})();

if (typeof module !== "undefined") {
    module.exports = JsDiff;
}

// node_modules/markdown-list-types/list-types.js
function listTypes(str) {
  str = str.replace(/\r\n|\r/g, '\n')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  var lines = str.split('\n');
  lines.forEach(function(line, i) {
    line = line.replace(/^(\s*)([ivx]+)\.\s(?=.)/i, function(match, whitespace, roman_num) {
      return whitespace + romanToDecimal(roman_num) + '. ';
    });
    line = line.replace(/^(\s*)([a-z]+)\.\s(?=.)/i, function(match, whitespace, alpha) {
      return whitespace + (alpha.toUpperCase().charCodeAt(0) - 64) + '. ';
    });
    lines[i] = line;
  });
  return lines.join('\n');
}

var roman_vals = {
  'i': 1,
  'v': 5,
  'x': 10
}
function romanToDecimal(roman) {
  roman = roman.toLowerCase();
  var total = 0;
  for (var n = 0; n < roman.length; ++n) {
    var letter = roman[n];
    var val = roman_vals[letter];

    if (letter == 'i' && (roman[n + 1] == 'v' || roman[n + 1] == 'x'))
      total -= val;
    else
      total += val;
  }
  return total;
}

if (typeof require != 'undefined') 
  module.exports = listTypes;
// node_modules/simple-markdown-tables/simple_tables.js
(function(root) {
var _ = root._ || require('underscore');
if (!_.str)
  _.str = require('underscore.string');

simpleTables.SPACES_BTWN_COLS = 1;
simpleTables.TAB_SIZE = 8;

function simpleTables(str) {
  str = str.replace(/\r\n|\r/g, '\n')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');
  
  var sections = str.split(/\n\s*\n/);
  sections.forEach(function(section, i) {
    var lines = section.replace(/(^\n+|\n+$)/g, '').split('\n');
    if (lines.length < 2)
      return;

    lines = expandTabs(lines);
    var cols = getColumns(lines);
    if (cols && isTable(cols, lines))
      sections[i] = simpleTable(cols, lines);
  });
  return sections.join('\n\n');
}

function expandTabs(lines) {
  return lines.map(function(line) {
    var ix_offset = 0;
    return line.replace(/\t/g, function(match, ix) {
      var num_spaces = simpleTables.TAB_SIZE - ((ix + ix_offset) % simpleTables.TAB_SIZE);
      ix_offset += num_spaces - 1;
      return _.str.repeat(' ', num_spaces);
    });
  });
}

function getColumns(lines) {
  var header = lines[0];
  
  // we can't use word boundaries b/c col headings can be non-words, like "#"
  var col_break = /\s\s(?=\S)/g; // *assumes* simpleTables.SPACES_BTWN_COLS = 1
  var col_widths = _.pluck(header.split(col_break), 'length');

  // col_break eats 1 whitespace char on all but the last col; add it back
  col_widths = col_widths.map(function(col_width, i) {
    if (i == col_widths.length - 1)
      return col_width;
    else
      return col_width + 1;
  });

  // expand last col_width to longest line
  if (col_widths.length)
    col_widths[col_widths.length - 1] += _.max(_.pluck(lines, 'length')) - header.length;
  return col_widths;
}

function isTable(cols, lines) {
  var is_table = cols.length >= 2;
  if (isList(cols, lines))
    return false;

  var col_pos = 0;
  cols.forEach(function(col_width, i) {
    col_pos += col_width;
    lines.forEach(function(line) {
      if (line.length > col_pos && !/\s/.test(line[col_pos]))
        is_table = false;
    });
    col_pos += simpleTables.SPACES_BTWN_COLS;
  });
  
  return is_table;
}

function isList(cols, lines) {
  return cols.length == 2
    && lines[0].slice(0, cols[0]).match(/^\w\.\s*$/);
}

function simpleTable(col_widths, lines) {
  lines = lines.map(function(line) {
    var line_arr = col_widths.map(function(col_width) {
      var cell_contents = line.slice(0, col_width);
      line = line.slice(col_width + simpleTables.SPACES_BTWN_COLS);
      return cell_contents;
    });

    line_arr = line_arr.map(function(cell_contents, i) {
      return _.str.rpad(cell_contents, col_widths[i]);
    });

    return '| ' + line_arr.join(' | ') + ' |';
  });

  var dashes = col_widths.map(function(col_width) {
    return _.str.repeat('-', col_width);
  });
  lines.splice(1, 0, '| ' + dashes.join(' | ') + ' |');

  return lines.join('\n');
}

function alignColumns(str) {
  var sections = str.split(/\n\s*\n/);
  sections = sections.map(function(section, index) {
    var lines = section.trim().split('\n');

    if (!isTSV(lines))
      return section;

    var result = alignTSV(lines);
    if (index == 0)
      result = '\n\n' + result;

    if (index == sections.length - 1)
      result = result + '\n\n';

    return result;
  });
  return sections.join('\n\n');
}

function isTSV(lines) {
  var num_tabs_per_line = null;
  var is_tsv = lines.length > 1;

  lines.forEach(function(line) {
    var num_tabs = numTabs(line);
    if (!num_tabs)
      is_tsv = false;
    if (num_tabs_per_line == null)
      num_tabs_per_line = num_tabs;
    else if (num_tabs > num_tabs_per_line)
      is_tsv = false;
  });

  return is_tsv;
}

function numTabs(line) {
  var tab = /\t/g;
  var result, num_tabs = 0;
  while (result = tab.exec(line))
    num_tabs++;
  return num_tabs;
}

function alignTSV(lines) {
  var max_lengths = [];
  lines.forEach(function(line) {
    line.split('\t').forEach(function(col, i) {
      var max_len = max_lengths[i];
      if (max_len == null)
        max_lengths[i] = col.length + 1; // header columns must have at least 2 spaces between cols
      else if (max_len < col.length)
        max_lengths[i] = col.length;
    });
  });
  
  lines.forEach(function(line, j) {
    var cols = line.split('\t');
    cols.forEach(function(col, i) {
      if (i == cols.length - 1)
        return;

      var target_len = max_lengths[i] + 1; // need at least 1 space btwn cols
      var first_tab_len = simpleTables.TAB_SIZE - (col.length % simpleTables.TAB_SIZE);
      var num_tabs = Math.ceil((target_len - (col.length + first_tab_len)) / simpleTables.TAB_SIZE);

      col += '\t';
      for (var n = 0; n < num_tabs; ++n)
        col += '\t';
      
      cols[i] = col;
    });
    lines[j] = cols.join('');
  });
  return lines.join('\n');
}

function sum(arr) { 
  return _.reduce(arr, function(memo, num) {
    return memo + num;
  }, 0);
}

simpleTables.alignColumns = alignColumns;
simpleTables.expandTabs = expandTabs;
simpleTables.isTSV = isTSV;
simpleTables.numTabs = numTabs;

if (typeof module != 'undefined')
  module.exports = simpleTables;
else
  root.simpleTables = simpleTables;
})(this);
// index.js
(function(root) {
  
var original = '';
var Backbone = root.Backbone || require('backbone');
var marked = root.marked || require('marked'),
    JsDiff = root.JsDiff || require('diff'),
    simpleTables = root.simpleTables || require('simple-markdown-tables'),
    listTypes = root.listTypes || require('markdown-list-types'),
    _ = root._ || require('underscore');

var text_events;
if (root.window && window.document)
  text_events = document.createEvent('TextEvent').initTextEvent;

if (root._) 
  _.str = root._.str;
else
  _.str = require('underscore.string');

marked.setOptions({'breaks': true, 'preserveNumbering': true});
simpleTables.TAB_SIZE = 4;

var editor_view = Backbone.View.extend({
  
  'events': {
    'keydown textarea': 'handleTabs',
    'keyup textarea': 'onChange',
    'input textarea': 'onChange',
    'paste textarea': 'onPaste',
    'shown .nav-tabs a': 'autoSize',
    'change input.wrapText': 'onWrapChange',
    'focus textarea': 'onTextFocus',
    'click .hide_editor': 'onHideClick'
  },
  
  'initialize': function initialize() {
    this.textarea = $('<textarea class="span12" id="' + this.cid + '" />');
    $(window).resize(this.autoSize.bind(this));
    this.original_text = this.options.original_text;
    var current_text = this.options.current_text || this.options.original_text;
    this.textarea.val(current_text);
  },

  'createTabLinks': function createTabLinks() {
    var tab_links = $('<ul class="nav nav-tabs" />');
    this.result_link = $('<a href="#result' + this.cid + '" data-toggle="tab">Preview</a>');
    this.diff_link = $('<a href="#diff' + this.cid + '" data-toggle="tab">Difference</a>');
    tab_links.append($('<li />').append(this.result_link));
    tab_links.append($('<li />').append(this.diff_link));
    tab_links.append(this.createHideLink());
    tab_links.append(this.createWrapCheckbox());
    return tab_links;
  },

  'createHideLink': function createHideLink() {
    var hide_link_container = $('<li />').css('float', 'right');
    var hide_link = $('<a class="hide_editor close" style="cursor: pointer">&times;</a>');
    hide_link_container.append(hide_link);
    return hide_link_container;
  },

  'createWrapCheckbox': function createWrapCheckbox() {
    var wrap_container = $('<li" />');
    var wrap_label = $('<label />');
    this.wrap_checkbox = $('<input type="checkbox" checked="checked" class="wrapText">');
    wrap_label.append(this.wrap_checkbox);
    wrap_label.append(' Wrap Text');
    wrap_container.css('float', 'right');
    return wrap_container.append(wrap_label);
  },

  'createTabContent': function createTabContent() {
    var tab_content = $('<div class="tab-content" />');
    this.result_tab = $('<div id="result' + this.cid + '" class="tab-pane table table-striped table-bordered"></div>');
    this.diff_tab = $('<div id="diff' + this.cid + '" class="tab-pane table table-striped table-bordered"></div>');
    tab_content.append(this.result_tab);
    tab_content.append(this.diff_tab);
    return tab_content;
  },
  
  'autoSize': function autoSize() {
    var $textarea = $(this.textarea);
    var borders = parseInt($textarea.css("borderTopWidth"), 10) + parseInt($textarea.css("borderBottomWidth"), 10);
    if ($textarea.outerHeight() < this.scrollHeight + borders)
      $textarea.height(250);

    var target = this.$('.tab-pane.active')[0];
    if (this.scrollHeight == this.clientHeight) {
      $(target).height('auto');
    }
    else {
      var scroll_diff = getScrollHeightDiff.apply(this);
      $(target).height(0);
      var target_borders = parseInt($(target).css("borderTopWidth"), 10) + parseInt($(target).css("borderBottomWidth"), 10);
      var target_padding = parseInt($(target).css("paddingTop"), 10) + parseInt($(target).css("paddingBottom"), 10);
      $(target).height(target.scrollHeight + target_borders - target_padding - scroll_diff);
      this.autoScroll();
    }
  },

  'onWrapChange': function onWrapChange() {
    if (this.wrap_checkbox.is(':checked'))
      this.textarea.removeAttr('wrap');
    else
      this.textarea.attr('wrap', 'off');
  },
  
  'autoScroll': function autoScroll() {
    var target = this.$('.tab-pane.active')[0];
    var scroll_percent = this.textarea.scrollTop / (this.textarea.scrollHeight - this.textarea.clientHeight);
    target.scrollTop = scroll_percent * (target.scrollHeight - target.clientHeight);
  },
  
  'getScrollHeightDiff': function getScrollHeightDiff() {
    var borders = parseInt($(this.textarea).css("borderTopWidth"), 10) + parseInt($(this.textarea).css("borderBottomWidth"), 10);
    var scroll_diff = this.textarea.scrollHeight + borders - $(this.textarea).outerHeight();
    if (scroll_diff > 0)
      return scroll_diff;
    return 0;
  },
  
  'handleTabs': function handleTabs(e) {
    if ((e.keyCode || e.which) != 9) return;
    e.preventDefault();

    var start = this.textarea.selectionStart;
    var val = $(this.textarea).val();
    $(this.textarea).val(val.slice(0, start) + '\t' + val.slice(this.textarea.selectionEnd));
    this.textarea.selectionStart = this.textarea.selectionEnd = start + 1;
  },
  
  'onPaste': function onPaste(evt) {
    var orig = this.textarea.val();
    setTimeout(function() {
      var current = $(this.textarea).val();
      var bounds = editor_view.getBoundsOfChange(orig, current);
      var pasted = current.slice(bounds.start, bounds.end);
      var processed = editor_view.processPastedText(pasted);
      if (processed == pasted)
        return;

      if (text_events) {
        updateTextarea(this.textarea, processed, bounds.start, bounds.end);
      }
      else {
        var merged = current.slice(0, bounds.start) + processed + current.slice(bounds.end);
        $(this.textarea).val(merged);
      }

      this.onChange();
    }.bind(this), 0);
  },
  
  'onChange': function onChange() {
    this.result_tab.html(editor_view.markdownToHTML(this.textarea.val()));
    this.createDiff();
    this.autoSize();
    this.trigger('change', this.textarea.val());
  },

  'createDiff': function createDiff() {
    var diff = JsDiff.diffWords(this.original_text, this.textarea.val());
    var fragment = document.createDocumentFragment();
    for (var i=0; i < diff.length; i++) {

      if (diff[i].added && diff[i + 1] && diff[i + 1].removed) {
        var swap = diff[i];
        diff[i] = diff[i + 1];
        diff[i + 1] = swap;
      }

      var node;
      if (diff[i].removed) {
        node = document.createElement('del');
        node.appendChild(document.createTextNode(diff[i].value));
      } else if (diff[i].added) {
        node = document.createElement('ins');
        node.appendChild(document.createTextNode(diff[i].value));
      } else {
        node = document.createTextNode(diff[i].value);
      }
      fragment.appendChild(node);
    }

    this.diff_tab.empty().append(fragment);
  },

  // TODO: update this to take start/end into account
  // & just update the pasted text
  'updateTextarea': function updateTextarea(textarea, text, start, end) {
    // don't break chrome's undo/redo: http://stackoverflow.com/questions/7553430
    var event = document.createEvent('TextEvent');
    textarea.select();
    textarea.selectionStart = start;
    textarea.selectionEnd = end;
    event.initTextEvent('textInput', true, true, null, text);
    textarea.dispatchEvent(event);
  },

  'onTextFocus': function() {
    this.$('.tab-container').slideDown();
  },

  'onHideClick': function() {
    this.$('.tab-container').slideUp();
  },

  'render': function render() {
    this.$el.append(this.textarea);
    var tab_container = $('<div />').css('display', 'none').addClass('tab-container');
    tab_container.append(this.createTabLinks());
    tab_container.append(this.createTabContent());
    this.$el.append(tab_container);
    this.onChange();
    this.$('div')
    this.$('.nav-tabs li:first').addClass('active');
    this.$('.tab-content > div:first').addClass('active');
    this.$('.tab-content > div').attr('style', 'height: auto;');
    return this;
  }
});

editor_view.processPastedText = function processPastedText(pasted_text) {
  var text = editor_view.normalizeNewLines(pasted_text);
  text = editor_view.insertMarkdownSeparatorLines(text);
  text = editor_view.handleWordLists(text);
  return simpleTables.alignColumns(text);
}

editor_view.normalizeNewLines = function normalizeNewLines(pasted_text) {
  return pasted_text.replace(/\r\n/g, '\n');
}

editor_view.insertMarkdownSeparatorLines = function insertMarkdownSeparatorLines(text) {
  var lines = text.split('\n');
  var previous_is_list, current_is_list, earliest_matching_index, output = [];
  var tab_counts = lines.map(function(line) { 
    return simpleTables.numTabs(line); 
  });
  var cur_tabs, prev_tabs, next_tabs, is_table, is_prev_table;

  lines.forEach(function(line, index) {
    current_is_list = editor_view.isList(line);

    // list starting/ending
    if (line && previous_is_list != null && previous_is_list != current_is_list)
      output.push('');
    
    // table starting ending
    if (!current_is_list) {
      cur_tabs = tab_counts[index];
      prev_tabs = tab_counts[index - 1];
      next_tabs = tab_counts[index + 1];
      is_table = cur_tabs && (prev_tabs == cur_tabs || next_tabs == cur_tabs);

      if (is_prev_table != null && is_table != is_prev_table)
        output.push('');
      is_prev_table = is_table;
    }

    output.push(line);
    previous_is_list = current_is_list;
  });
  
  return output.join('\n');
}

editor_view.handleWordLists = function handleWordLists(text) {
  var lines = text.split('\n');
  return lines.map(function(line) {
    bull_replacements.forEach(function(repl) {
      line = line.replace(repl[0], repl[1]);
    });
    return line;
  }).join('\n');
}

editor_view.isList = function isList(line) {
  return _(bull_replacements).any(function(item) {
    return item[0].test(line);
  });
}

var bull_replacements = [
  [/^(\d+)\.\t/, '$1. '],
  [/^([a-h])\.\t/, '\t$1. '],
  [/^([ivx]+)\.\t/, '\t\t$1. '], 
  [/^\u2022\t/, '* '],
  [/^o\t/, '\t* '],
  [/^\uf0a7\t/, '\t\t* ']
];

editor_view.getBoundsOfChange = function getBoundsOfChange(orig_text, new_text) {
  var orig_len = orig_text.length;
  var new_len = new_text.length;

  var start = 0;
  while (orig_text[start] == new_text[start] && start < orig_len)
    start++;
  
  var end = 1;
  while (orig_text[orig_len - end] == new_text[new_len - end] && end <= new_len - start && end <= orig_len - start)
    end++;

  return {'start': start, 'end': new_len - (end - 1)};
}

editor_view.markdownToHTML = function markdownToHTML(md) {
  return marked(listTypes(simpleTables(md)));
}

if (typeof require != 'undefined') {
  // todo: convert these to static methods so they can be tests
  //    ie: editor_view.getBoundsOfChange = function getBoundsOfChange () {...etc
  exports.getBoundsOfChange = editor_view.getBoundsOfChange;
  exports.markdownToHTML = editor_view.markdownToHTML;
  exports.insertMarkdownSeparatorLines = editor_view.insertMarkdownSeparatorLines;
  exports.editor_view = editor_view;
}
else {
  root.editor_view = editor_view;
}
})(this);

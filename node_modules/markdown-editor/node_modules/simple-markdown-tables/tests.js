var assert = require('assert'),
    fs = require('fs'),
    st = require('./simple_tables');

var tests = {};

var contents = fs.readFileSync('./README.md', 'utf-8');
contents = contents.split('## ');
contents.shift();

contents.forEach(function(section) {
  if (/^Column-Aligned Tables/.test(section))
    tests.column_aligned = getTests(section);
  else if (/^Tab-Delimited Tables/.test(section))
    tests.tab_delimited = getTests(section);
  else if (/^Usage/.test(section))
    ;
  else
    throw new Error('Unknown section in README: ' + contents.slice(0, 50));
});

/// ignore
/// ```
/// input
/// ```
/// ignore
/// ```
/// expected output
/// ```
function getTests(section) {
  var tests = [];

  var fenced_blocks = [];
  section.split('```').forEach(function(block, i) {
    if (i % 2 == 1)
      fenced_blocks.push(block);
  });

  fenced_blocks.forEach(function(block, i) {
    if (i % 2 == 0)
      tests.push({'input': block});
    else
      tests[tests.length - 1].expected = block;
  });

  return tests;
}

describe('expandTabs', function() {
  var tests = [
    ['\t',          '        '],
    ['a\t',         'a       '],
    ['aa\t',        'aa      '],
    ['aaa\t',       'aaa     '],
    ['aaaa\t',      'aaaa    '],
    ['aaaaa\t',     'aaaaa   '],
    ['aaaaaa\t',    'aaaaaa  '],
    ['aaaaaaa\t',   'aaaaaaa '],
    ['aaaaaaaa\t',  'aaaaaaaa        '],
    ['aaaaaaaaa\t', 'aaaaaaaaa       '],
    ['\t\t',        '                '],
    ['a\t\t',       'a               '],
    ['aa\t\t',      'aa              ']
  ];
  tests.forEach(function(test, i) {
    it('Test ' + i, function() {
      assert.equal(st.expandTabs([test[0]])[0], test[1])
    })
  })
  it('should allow the user to specify a tab-size of 4', function() {
    st.TAB_SIZE = 4;
    assert.equal(st.expandTabs(['\t'])[0],      '    ');
    assert.equal(st.expandTabs(['a\t'])[0],     'a   ');
    assert.equal(st.expandTabs(['aaa\t'])[0],   'aaa ');
    assert.equal(st.expandTabs(['aaaa\t'])[0],  'aaaa    ');
    assert.equal(st.expandTabs(['aaaaa\t'])[0], 'aaaaa   ');
    st.TAB_SIZE = 8;
  });
});

describe('simple-tables', function() {
  for (var section in tests) {
    var fn = section == 'tab_delimited' ? st.alignColumns : st;
    describe(section, function() {
      tests[section].forEach(function(test, i) {    
        it('Test ' + (i + 1), function(fn) {
          assert.equal(fn(test.input).trim(), test.expected.trim());
        }.bind(null, fn));
      });
    });
  }

  it('should support columns aligned with spaces', function() {
    var input = [
      '```',
      'This is a paragraph above.',
      '',
      'Test   Heading 2  Heading 3',
      'Test2  Test3',
      'Test5',
      'Test6  is another test',
      'Test79 is a test',
      'Test8  Test9',
      '',
      'This is a paragraph below.',
      '```'
    ].join('\n');

    var expected = [
      '```',
      'This is a paragraph above.',
      '',
      '| Test   | Heading 2  | Heading 3 |',
      '| ------ | ---------- | --------- |',
      '| Test2  | Test3      |           |',
      '| Test5  |            |           |',
      '| Test6  | is another | test      |',
      '| Test79 | is a test  |           |',
      '| Test8  | Test9      |           |',
      '',
      'This is a paragraph below.',
      '```'
    ].join('\n');
    assert.equal(st(input), expected);
  });

  it('should not identify lists as tables', function() {
    var input = [
      '1. Test One',
      '2. Test Two',
      '3. Test Three'
    ].join('\n');
    assert.equal(st(input), input);
  });

  it('should not identify lists with two spaces as tables', function() {
    var input = [
      '1.  Test One',
      '2.  Test Two',
      '3.  Test Three'
    ].join('\n');
    assert.equal(st(input), input);
  });

  it('should not ignore different leading indentation', function() {
    var input = [
      'Test   Heading 2  Heading 3',
      '	Test2  Test3',
      '	Test5',
      '	Test6  is another test',
      '	Test79 is a test',
      '	Test8  Test9'
    ].join('\n');
    assert.equal(st(input), input);
  });

  it('should always generate all columns, even if there is no content', function() {
    var input = [
      'Test  One  Two',
      'Test  Two',
      'Test  Twor',
      'Test  The  Four'
    ].join('\n');

    var expected = [
      '| Test  | One  | Two  |',
      '| ----- | ---- | ---- |',
      '| Test  | Two  |      |',
      '| Test  | Twor |      |',
      '| Test  | The  | Four |'
    ].join('\n');
    assert.equal(st(input).replace(/ /g, '_').replace(/\n/g, '<LF>'), expected.replace(/ /g, '_').replace(/\n/g, '<LF>'));
  });

  it('should support non-words as headings (and not just in the 1st col)', function() {
    var input = [
      'Test  #  Test2',
      'My    2  Test',
      'The   3  Test'
    ].join('\n');

    var expected = [
      '| Test  | #  | Test2 |',
      '| ----- | -- | ----- |',
      '| My    | 2  | Test  |',
      '| The   | 3  | Test  |'
    ].join('\n');
    assert.equal(st(input), expected);
  });
});

describe('align columns', function() {
  it('should expand columns that end right on the tab stop (at 16 chars)', function() {
    var input = [
      'Row 1	Col2 (right)	Col3 (Center)	Col4 (left)',
      'Row 2	123.45  Centered	One	',
      'Row 3	748.29	Two	'
    ];

    var expected = [
      'Row 1	Col2 (right)		Col3 (Center)	Col4 (left)',
      'Row 2	123.45  Centered	One		',
      'Row 3	748.29			Two'
    ].join('\n');
    assert(st.isTSV(input));
    assert.equal(st.alignColumns(input.join('\n')).replace(/\t/g, ' T '), expected.replace(/\t/g, ' T '));
  });

  it('should fill empty tabs correctly with missing center & right values', function() {
    var input = [
      'Test	Test	Test',
      'Test		'
    ];

    assert(st.isTSV(input));
  });

  it('should fill empty tabs correctly with missing center value', function() {
    var input = [
      'Test	Test	Test',
      'Test		Test'
    ];

    assert(st.isTSV(input));
  });
});